from typing import List, AsyncGenerator
from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException, status, Depends
from pydantic import BaseModel, ConfigDict
from datetime import datetime
import uvicorn
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from models import Post as PostModel
from database import get_db, create_tables
from config import settings

# Lifespan –º–µ–Ω–µ–¥–∂–µ—Ä
@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    # Startup: —Å–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
    print("üöÄ Starting up... Creating tables")
    await create_tables()
    yield
    # Shutdown: –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –∑–∞–∫—Ä—ã—Ç–∏—è
    print("üî¥ Shutting down...")

app = FastAPI(
    title="Blog API", 
    version="1.0.0",
    lifespan=lifespan
)

class CreatePost(BaseModel):
    title: str
    content: str
    published: bool = True

class PostResponse(BaseModel):
    id: int
    title: str
    content: str
    published: bool
    created_at: datetime
    last_update: datetime | None = None
    
    model_config = ConfigDict(from_attributes=True)

@app.get("/")
async def root():
    return {"status": "server work"}

@app.get("/posts", response_model=List[PostResponse])
async def get_posts(skip: int = 0, limit: int = 100, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(PostModel).offset(skip).limit(limit))
    posts = result.scalars().all()
    return posts

@app.get("/posts/{post_id}", response_model=PostResponse)
async def get_post_by_id(post_id: int, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(PostModel).where(PostModel.id == post_id))
    post = result.scalar_one_or_none()
    if not post:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, 
            detail="–ü–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    return post

@app.post("/posts/", status_code=status.HTTP_201_CREATED)
async def create_post(post: CreatePost, db: AsyncSession = Depends(get_db)):
    db_post = PostModel(
        title=post.title,
        content=post.content,
        published=post.published,
        created_at=datetime.now()
    )
    db.add(db_post)
    await db.commit()
    await db.refresh(db_post)
    return {"msg": "–ü–æ—Å—Ç —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω", "id": db_post.id}

@app.put("/posts/{post_id}")
async def change_post(post_id: int, update: CreatePost, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(PostModel).where(PostModel.id == post_id))
    db_post = result.scalar_one_or_none()
    if not db_post:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, 
            detail="–ü–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    
    db_post.title = update.title
    db_post.content = update.content
    db_post.published = update.published
    db_post.last_update = datetime.now()
    
    await db.commit()
    await db.refresh(db_post)
    
    return {"msg": "–ü–æ—Å—Ç –∏–∑–º–µ–Ω–µ–Ω", "post": PostResponse.model_validate(db_post)}

@app.delete("/posts/{post_id}")
async def delete_post(post_id: int, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(PostModel).where(PostModel.id == post_id))
    db_post = result.scalar_one_or_none()
    if not db_post:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, 
            detail="–ü–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    
    await db.delete(db_post)
    await db.commit()
    
    return {"msg": "–ü–æ—Å—Ç —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω"}

if __name__ == "__main__":
    uvicorn.run(
        "main:app", 
        host="127.0.0.1", 
        port=8000, 
        reload=True
    )